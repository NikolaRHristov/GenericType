import{useCallback as y,useEffect as g,useMemo as h,useState as T}from"react";function O(p){function w(s,f={}){const{immediate:c=!0,transform:n,onError:a,suspense:v=!1,debounce:d=0}=f,r=h(()=>p.getReactive(s),[s]);if(!r&&v)throw new Error(`Reactive with id "${s}" not found`);const[m,o]=T(()=>{const e=r?.value();return n?n(e):e}),[u,i]=T(null),[S,E]=T(!1),C=y(async e=>{if(!r?.set)throw new Error(`Reactive "${s}" is read-only`);E(!0),i(null);try{const t=typeof e=="function"?e(m):e,l=n?n(t):t;await r.set(l),o(l)}catch(t){const l=t instanceof Error?t:new Error(String(t));i(l),a?.(l)}finally{E(!1)}},[r,s,m,n,a]);g(()=>{if(!r||!c)return;let e;const t=R=>{const b=()=>{const k=n?n(R):R;o(k)};d>0?(clearTimeout(e),e=setTimeout(b,d)):b()},l=p.subscribe(s,t);return()=>{l(),clearTimeout(e)}},[r,s,c,n,d]);const U=y(async()=>{if(r){E(!0),i(null);try{const e=r.value(),t=n?n(e):e;await r.set?.(t),o(t)}catch(e){const t=e instanceof Error?e:new Error(String(e));i(t),a?.(t)}finally{E(!1)}}},[r,n,a]);return{value:m,error:u,isLoading:S,setValue:C,reset:U,meta:{updateCount:r?.meta.updateCount??0,lastUpdated:r?.meta.lastUpdated,status:r?.meta.status??"idle"}}}function V(s,f,c={}){const a=f.map(o=>p.getReactive(o)).map(o=>o?.value()),v=h(()=>{try{return s(...a)}catch(o){const u=o instanceof Error?o:new Error(String(o));return c.onError?.(u),null}},[s,...a]),[d,r]=T(null),[m]=T(!1);return g(()=>{const o=u=>{r(u),c.onError?.(u)};f.forEach(u=>{p.subscribe(u,()=>{try{s(...a)}catch(i){o(i instanceof Error?i:new Error(String(i)))}})})},[f,s]),{value:c.transform?c.transform(v):v,error:d,isLoading:m,reset:async()=>{},meta:{updateCount:0,lastUpdated:void 0,status:d?"error":"success"}}}return{useReactive:w,useComputedReactive:V}}export{O as createReactiveHookFactory};
